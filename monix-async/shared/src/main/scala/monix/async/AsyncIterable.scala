/*
 * Copyright (c) 2014-2016 by its authors. Some rights reserved.
 * See the project homepage at: https://monix.io
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package monix.async

import monix.async.AsyncIterator._
import monix.execution.Scheduler
import scala.collection.LinearSeq
import scala.collection.mutable
import scala.concurrent.Future
import scala.util.control.NonFatal

/** The `AsyncIterable` is a generator of [[AsyncIterator]].
  *
  * Just like a normal `Iterable`, an asynchronous iterable is
  * a `Task` based variant of an iterable whose elements
  * can be generated asynchronously.
  *
  * @param iterator is the [[AsyncIterator]] generator.
  */
final case class AsyncIterable[+A](iterator: Task[AsyncIterator[A]]) {
  def map[B](f: A => B): AsyncIterable[B] =
    AsyncIterable(iterator.map(_.map(f)))

  def flatMap[B](f: A => AsyncIterable[B]): AsyncIterable[B] =
    AsyncIterable(iterator.map { iteratorA =>
      iteratorA.flatMap(a => Wait(f(a).iterator))
    })

  def flatten[B](implicit ev: A <:< AsyncIterable[B]): AsyncIterable[B] =
    flatMap(x => x)

  def foreach(f: A => Unit)(implicit s: Scheduler): CancelableFuture[Unit] = {
    def loop(task: Task[AsyncIterator[A]]): Task[Unit] = task.flatMap {
      case Next(elem, rest) =>
        try { f(elem); loop(rest) }
        catch { case NonFatal(ex) => s.reportFailure(ex); Task.unit }

      case NextSeq(elems, rest) =>
        try { elems.foreach(f); loop(rest) }
        catch { case NonFatal(ex) => s.reportFailure(ex); Task.unit }

      case Wait(rest) => loop(rest)
      case Empty => Task.unit
      case Error(ex) =>
        s.reportFailure(ex)
        Task.unit
    }

    loop(iterator).runAsync
  }
}

object AsyncIterable {
  /** Builder for an empty iterable. */
  def empty[A]: AsyncIterable[A] = emptyIterable

  /** Lifts a strict value into an `AsyncIterable` */
  def now[A](a: A): AsyncIterable[A] =
    AsyncIterable(Task.now(AsyncIterator.now(a)))

  /** Lifts a strict value into an `AsyncIterable` */
  def evalAlways[A](a: => A): AsyncIterable[A] =
    AsyncIterable(Task.now(AsyncIterator.evalAlways(a)))

  /** Lifts a strict value into an `AsyncIterable` and
    * memoizes the result for subsequent executions.
    */
  def evalOnce[A](a: => A): AsyncIterable[A] =
    AsyncIterable(Task.now(AsyncIterator.evalOnce(a)))

  /** Promote a non-strict value representing a AsyncIterable
    * to an AsyncIterator of the same type.
    */
  def defer[A](fa: => AsyncIterable[A]): AsyncIterable[A] =
    AsyncIterable(Task.defer(fa.iterator))

  /** Converts a task into an iterable emitting one element. */
  def fromTask[A](task: Task[A]): AsyncIterable[A] =
    AsyncIterable(task.map(AsyncIterator.now))

  /** Converts a future into an iterable emitting one element. */
  def fromFuture[A](future: Future[A]): AsyncIterable[A] =
    fromTask(Task.fromFuture(future))

  /** Converts a plain iterable into an async iterable. */
  def fromSeq[A](seq: Seq[A], batchSize: Int): AsyncIterable[A] =
    AsyncIterable(AsyncIterator.fromSeq(seq, batchSize))

  /** Converts a plain iterable into an async iterable. */
  def fromIterable[A](iterable: Iterable[A], batchSize: Int): AsyncIterable[A] =
    AsyncIterable(AsyncIterator.fromIterable(iterable, batchSize))

  /** Converts a plain iterator into an async iterator. */
  def fromIterator[A](iterator: Iterator[A], batchSize: Int): AsyncIterable[A] =
    AsyncIterable(AsyncIterator.fromIterator(iterator, batchSize))

  private final val emptyIterable = AsyncIterable(Task.now(Empty))
}

/** An `AsyncIterator` represents a [[Task]] based asynchronous
  * iterator, generated by [[AsyncIterable]].
  */
sealed trait AsyncIterator[+A] {
  def filter(p: A => Boolean): AsyncIterator[A] =
    this match {
      case ref @ Next(head, tail) =>
        try { if (p(head)) ref else Wait(tail) }
        catch { case NonFatal(ex) => Error(ex) }
      case NextSeq(head, rest) =>
        try head.filter(p) match {
          case Nil => Wait(rest)
          case filtered => NextSeq(filtered, rest)
        } catch {
          case NonFatal(ex) => Error(ex)
        }
      case Wait(rest) => Wait(rest.map(_.filter(p)))
      case Empty => Empty
      case Error(ex) => Error(ex)
    }

  final def map[B](f: A => B): AsyncIterator[B] =
    this match {
      case Next(head, tail: Task[AsyncIterator[A]]) =>
        try { Next(f(head), tail.map(_.map(f))) }
        catch { case NonFatal(ex) => Error(ex) }
      case NextSeq(head, rest) =>
        try { NextSeq(head.map(f), rest.map(_.map(f))) }
        catch { case NonFatal(ex) => Error(ex) }

      case Wait(rest) => Wait(rest.map(_.map(f)))
      case Empty => Empty
      case Error(ex) => Error(ex)
    }

  final def flatMap[B](f: A => AsyncIterator[B]): AsyncIterator[B] =
    this match {
      case Next(head, tail: Task[AsyncIterator[A]]) =>
        try { f(head) ++ Wait(tail.map(_.flatMap(f))) }
        catch { case NonFatal(ex) => Error(ex) }
      case NextSeq(list, rest) =>
        try {
          if (list.isEmpty)
            Wait(rest.map(_.flatMap(f)))
          else
            f(list.head) ++ NextSeq(list.tail, EmptyTask).flatMap(f) ++ Wait(rest.map(_.flatMap(f)))
        } catch {
          case NonFatal(ex) => Error(ex)
        }

      case Wait(rest) => Wait(rest.map(_.flatMap(f)))
      case Empty => Empty
      case Error(ex) => Error(ex)
    }

  final def flatten[B](implicit ev: A <:< AsyncIterator[B]): AsyncIterator[B] =
    flatMap(x => x)

  final def ++[B >: A](rhs: AsyncIterator[B]): AsyncIterator[B] =
    this match {
      case Wait(task) =>
        Wait(task.map(_ ++ rhs))
      case Next(a, lt) =>
        Next(a, lt.map(_ ++ rhs))
      case NextSeq(head, lt) =>
        NextSeq(head, lt.map(_ ++ rhs))
      case Empty => rhs
      case Error(ex) => Error(ex)
    }
}

object AsyncIterator {
  /** A state of the [[AsyncIterator]] representing a deferred iterator. */
  final case class Wait[+A](next: Task[AsyncIterator[A]]) extends AsyncIterator[A]

  /** Builder for a [[Wait]] iterator state. */
  def wait[A](rest: Task[AsyncIterator[A]]): AsyncIterator[A] = Wait(rest)

  /** A state of the [[AsyncIterator]] representing a head/tail decomposition.
    *
    * @param head is the next element to be processed
    * @param rest is the next state in the sequence
    */
  final case class Next[+A](head: A, rest: Task[AsyncIterator[A]]) extends AsyncIterator[A]

  /** Builds a [[Next]] iterator state. */
  def next[A](head: A, rest: Task[AsyncIterator[A]]): AsyncIterator[A] =
    Next(head, rest)

  /** A state of the [[AsyncIterator]] representing a head/tail decomposition.
    *
    * Like [[Next]] except that the head is a strict sequence
    * of elements that don't need asynchronous execution.
    * Meant for doing buffering.
    *
    * @param headSeq is a sequence of the next elements to be processed, can be empty
    * @param rest is the next state in the sequence
    */
  case class NextSeq[+A](headSeq: LinearSeq[A], rest: Task[AsyncIterator[A]]) extends AsyncIterator[A]

  /** Builds a [[Next]] iterator state. */
  def nextSeq[A](headSeq: LinearSeq[A], rest: Task[AsyncIterator[A]]): AsyncIterator[A] =
    NextSeq(headSeq, rest)

  /** Represents an error state in the iterator.
    *
    * This is a final state. When this state is received, the data-source
    * should have been canceled already.
    *
    * @param ex is an error that was thrown.
    */
  case class Error(ex: Throwable) extends AsyncIterator[Nothing]

  /** Builder for an [[Error]] state. */
  def error[A](ex: Throwable): AsyncIterator[A] = Error(ex)

  /** Represents an empty iterator.
    *
    * Received as a final state in the iteration process.
    * When this state is received, the data-source should have
    * been canceled already.
    */
  case object Empty extends AsyncIterator[Nothing]

  /** Builder for an [[Empty]] state. */
  def empty[A]: AsyncIterator[A] = Empty

  /** Lifts a strict value into an `AsyncIterator` */
  def now[A](a: A): AsyncIterator[A] = Next(a, EmptyTask)

  /** Lifts a strict value into an `AsyncIterable` */
  def evalAlways[A](a: => A): AsyncIterator[A] =
    Wait(Task.evalAlways(try Next(a, EmptyTask) catch { case NonFatal(ex) => Error(ex) }))

  /** Lifts a strict value into an `AsyncIterable` and
    * memoizes the result for subsequent executions.
    */
  def evalOnce[A](a: => A): AsyncIterator[A] =
    Wait(Task.evalOnce(try Next(a, EmptyTask) catch { case NonFatal(ex) => Error(ex) }))

  /** Promote a non-strict value representing a AsyncIterator
    * to an AsyncIterator of the same type.
    */
  def defer[A](fa: => AsyncIterator[A]): Wait[A] =
    Wait(Task.defer(Task.evalAlways(fa)))

  /** Converts any sequence into an async iterator. */
  def fromSeq[A](seq: Seq[A], batchSize: Int): Task[AsyncIterator[A]] =
    Task.now(seq).map(seq => NextSeq[A](seq.toList, EmptyTask))

  /** Converts an iterable into an async iterator. */
  def fromIterable[A](iterable: Iterable[A], batchSize: Int): Task[AsyncIterator[A]] =
    Task.evalAlways(iterable.iterator).flatMap { iterator => fromIterator(iterator, batchSize) }

  /** Converts an iterator into an async iterator. */
  def fromIterator[A](iterator: Iterator[A], batchSize: Int): Task[AsyncIterator[A]] =
    Task.now(iterator).map { iterator =>
      try {
        val buffer = mutable.ListBuffer.empty[A]
        var processed = 0
        while (processed < batchSize && iterator.hasNext) {
          buffer += iterator.next()
          processed += 1
        }

        if (processed == 0) Empty else
          NextSeq(buffer.toList, fromIterator(iterator, batchSize))
      } catch {
        case NonFatal(ex) => Error(ex)
      }
    }

  // Reusable instances
  private[async] final val EmptyTask = Task.now(Empty)
}